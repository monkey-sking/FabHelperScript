### **Fab Helper 脚本开发需求文档 (v2.0)**

#### **1. 项目概述**

本项目的目标是创建一个用户脚本（UserScript），用于辅助用户在 Fab.com 网站上自动获取免费的3D资产。脚本应提供一个清晰的图形用户界面（GUI），能够稳定地执行批量任务，并能智能地适应网站的动态加载特性（如无限滚动和单页应用导航）。

#### **2. 核心功能需求 (用户故事)**

| 角色 | 需求/故事 | 目标 |
| :--- | :--- | :--- |
| 作为用户 | 我希望能一键启动任务 | 脚本能自动扫描当前页面的所有免费资产，并将它们加入待办队列，然后逐一获取。 |
| 作为用户 | 我希望脚本能处理许可证弹窗 | 在获取需要选择许可证的资产时，脚本能自动选择“标准版”并确认。 |
| 作为用户 | 我希望能清晰地看到每个资产的状态 | 脚本需要在商品卡片上用直观的标记（如 `✔` 和 `✖`）来显示“已入库”和“获取失败”的状态。 |
| 作为用户 | 我希望能够隐藏我已经拥有的资产 | 我可以点击一个按钮，将所有“已入库”的商品卡片从页面上隐藏，以减少干扰。再次点击可以恢复显示。 |
| 作为用户 | 我希望脚本能适应无限滚动 | 当我向下滚动页面，动态加载出新的商品时，脚本能自动识别它们，并应用“状态标记”和“隐藏”逻辑。 |
| 作为用户 | 我希望任务执行是稳定且持续的 | 脚本不应该在处理几个任务后就卡死或停止，它应该能持续处理，直到待办队列为空。 |
| 作为用户 | 我希望所有数据都能被妥善保存 | 我的“已入库”和“失败”列表，以及“隐藏”偏好，都应该被持久化保存在浏览器中，刷新页面或下次访问时不会丢失。 |

#### **3. 技术逻辑与架构设计**

脚本采用“主控端+工作端”(Controller-Worker)的模式。

**3.1. 主控端逻辑 (运行于用户浏览的主页面)**

*   **UI模块**:
    *   负责在页面右下角渲染一个固定的控制面板。
    *   面板显示四个核心统计数据：**待办**、**已入库**、**失败**、**已隐藏**。
    *   提供三个核心操作按钮：**一键开刷/停止**、**隐藏/显示已得**、**同步状态**。
    *   负责在商品卡片上创建/移除 `✔` (owned) 和 `✖` (failed) 的视觉覆盖层。

*   **任务扫描与管理模块**:
    *   **扫描逻辑**: 遍历页面上所有的商品卡片 (`div.AssetCard-root`)。
    *   **任务筛选**: 对于每个卡片，需满足以下所有条件才被视为一个有效任务：
        1.  是免费的 (根据 `Config.FREE_TEXT_SET` 中的关键词判断)。
        2.  数据库中没有“已入库”记录 (`Database.isDone`)。
        3.  数据库中没有“失败”记录 (`Database.isFailed`)。
        4.  当前“待办”队列中不存在。
    *   **队列管理**: 将符合条件的任务（包含`name`和`url`）存入内存中的`State.db.todo`数组。

*   **任务调度模块**:
    *   当用户点击“一键开刷”时启动。
    *   循环检查“待办”队列和当前活跃的“工作端”数量 (`State.activeWorkers`)。
    *   在活跃工作端数量未达到上限（`Config.MAX_WORKERS`）且队列不为空时，从队列头部取出一个任务，派发出去。
    *   **派发方式**:
        1.  生成一个唯一的 `workerId`。
        2.  将任务数据和 `workerId` 存入 `GM_setValue`。
        3.  使用 `GM_openInTab` 在一个不激活的新标签页中打开任务URL，并将 `workerId` 作为URL参数。

*   **状态与数据持久化模块**:
    *   使用 `GM_getValue` 在脚本启动时加载 `done` 和 `failed` 列表到内存。
    *   `done` 列表 (`fab_doneList_v8`): 存储所有已成功获取资产的URL字符串。
    *   `failed` 列表 (`fab_failedList_v8`): 存储获取失败的完整任务对象（`{name, url}`）。
    *   当任务成功或失败时，更新相应列表并使用 `GM_setValue` 写回。
    *   用户的“隐藏”偏好 (`fab_hideSaved_v8`) 也使用同样方式读写。

**3.2. 工作端逻辑 (运行于被打开的新标签页)**

*   **初始化**: 页面加载后，从URL参数中获取自己的 `workerId`。
*   **获取任务**: 使用 `workerId` 从 `GM_getValue` 中读取自己的任务数据，然后立刻删除该键值，防止重复执行。
*   **核心UI交互**:
    1.  等待页面加载完成。
    2.  首先检查当前资产是否已经是“拥有”状态，如果是，则直接判定为成功。
    3.  查找“添加到我的库”或类似按钮。
    4.  点击按钮后，等待页面反应。
    5.  **处理许可证弹窗**: 如果出现许可证弹窗 (`div[role="dialog"]`)，则查找包含“Standard License”文本的选项并点击，然后点击弹窗的确认按钮。
    6.  **结果验证**: 持续检查页面，直到出现“已保存在我的库中”或类似的成功标识，才判定为成功。如果在超时（如10秒）后仍未出现，则判定为失败。
*   **结果上报**:
    *   无论成功或失败，都将结果（`{ workerId, success, task }`）通过 `GM_setValue` 写入到**同一个**、**固定**的键 (`Config.DB_KEYS.WORKER_DONE`) 上。
    *   短暂延时后，使用 `window.close()` 关闭自己。

**3.3. 动态页面适应逻辑**

*   **无限滚动 (`MutationObserver`)**:
    *   一个 `MutationObserver` 实例将监视商品网格容器 (`#root div.AssetGrid-root`)。
    *   当检测到有新的子节点（新的商品卡片）被添加时，自动触发一次 **页面状态刷新** (`PagePatcher.run`)。
    *   如果“一键开刷”正在运行中，则额外触发一次 **任务扫描** (`TaskRunner.scanForTasks`)。

*   **页面状态刷新逻辑 (`PagePatcher.run`)**:
    *   遍历页面上所有商品卡片。
    *   对每个卡片，检查其在数据库中的状态（`isDone`, `isFailed`）。
    *   根据状态，以及用户是否开启“隐藏”，来决定是**显示 `✔`**、**显示 `✖`**、**直接隐藏卡片**，还是**保持原样**。
