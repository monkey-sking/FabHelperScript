# 代码精简建议

## 一、重复代码模式精简

### 1. CSRF Token 检查优化
当前代码中有5处重复的 CSRF token 检查模式：
```javascript
const csrfToken = Utils.getCookie('fab_csrftoken');
if (!csrfToken) {
    Utils.checkAuthentication();
    throw new Error("CSRF token not found");
}
```

**建议**：创建一个统一的函数来获取并验证 token
```javascript
// 添加到 Utils 对象
getCsrfTokenOrFail: () => {
    const token = Utils.getCookie('fab_csrftoken');
    if (!token) {
        Utils.checkAuthentication();
        throw new Error("CSRF token not found");
    }
    return token;
}

// 使用示例
const csrfToken = Utils.getCsrfTokenOrFail();
```

### 2. 延时处理函数
多处使用了相似的延时代码：
```javascript
await new Promise(r => setTimeout(r, 250));
```

**建议**：添加通用延时函数
```javascript
// 添加到 Utils 对象
delay: (ms) => new Promise(resolve => setTimeout(resolve, ms))

// 使用示例
await Utils.delay(250);
```

## 二、过长函数拆分

### 1. processDetailPage 函数（约200行）
**建议拆分为**：
- `checkWorkerValidity()` - 验证工作标签页有效性
- `performPageDiagnosis()` - 执行页面诊断
- `checkOwnershipViaAPI()` - API 方式检查拥有状态
- `performUIInteraction()` - 执行 UI 交互
- `reportWorkerResult()` - 报告工作结果

### 2. UI.create 函数
**建议拆分为**：
- `createMainPanel()` - 创建主面板
- `createTabs()` - 创建标签页
- `createDashboard()` - 创建仪表板
- `createSettings()` - 创建设置面板
- `createDebugPanel()` - 创建调试面板

## 三、通用函数提取

### 1. API 请求封装
当前多处使用相似的 API 请求模式，建议创建通用函数：
```javascript
// API 对象添加
makeAuthenticatedRequest: async (url, params = {}) => {
    const csrfToken = Utils.getCsrfTokenOrFail();
    const defaultHeaders = {
        'x-csrftoken': csrfToken,
        'x-requested-with': 'XMLHttpRequest'
    };
    
    return API.gmFetch({
        method: 'GET',
        url: url,
        headers: { ...defaultHeaders, ...params.headers },
        ...params
    });
}
```

### 2. 批量处理优化
多处有批量处理逻辑，可以提取通用函数：
```javascript
// Utils 添加
processInChunks: async (items, chunkSize, processor, delayMs = 0) => {
    const results = [];
    for (let i = 0; i < items.length; i += chunkSize) {
        const chunk = items.slice(i, i + chunkSize);
        const chunkResults = await processor(chunk);
        results.push(...chunkResults);
        
        if (i + chunkSize < items.length && delayMs > 0) {
            await Utils.delay(delayMs);
        }
    }
    return results;
}
```

## 四、配置常量优化

### 1. 合并相关常量
将分散的超时、延时等常量集中管理：
```javascript
Config.DELAYS = {
    API_CHUNK: 250,
    WORKER_CHECK: 200,
    PAGE_LOAD: 3000,
    FORCE_CLOSE: 60000,
    // ...其他延时常量
};
```

### 2. 文本常量重构
当前的 TEXTS 对象过大，建议按功能模块拆分：
```javascript
Config.TEXTS = {
    en: {
        ui: { /* UI相关文本 */ },
        log: { /* 日志相关文本 */ },
        status: { /* 状态相关文本 */ },
        error: { /* 错误相关文本 */ }
    },
    zh: {
        // 同样的结构
    }
};
```

## 五、状态管理优化

### 1. 减少 GM_getValue 调用
可以在启动时批量读取常用配置：
```javascript
// 初始化时批量加载
const loadInitialState = async () => {
    const [appStatus, lastCursor, autoAdd, rememberPos] = await Promise.all([
        GM_getValue(Config.DB_KEYS.APP_STATUS),
        GM_getValue(Config.DB_KEYS.LAST_CURSOR),
        GM_getValue(Config.DB_KEYS.AUTO_ADD, false),
        GM_getValue(Config.DB_KEYS.REMEMBER_POS, false)
    ]);
    
    // 批量设置状态
    Object.assign(State, {
        appStatus: appStatus?.status || 'NORMAL',
        lastCursor,
        autoAdd,
        rememberPos
    });
};
```

## 六、错误处理统一

创建统一的错误处理函数：
```javascript
// Utils 添加
handleError: (error, context, shouldStop = false) => {
    Utils.logger('error', `[${context}] ${error.message}`);
    
    if (shouldStop && State.isExecuting) {
        State.isExecuting = false;
        GM_setValue(Config.DB_KEYS.IS_EXECUTING, false);
        UI.updateExecutionButton();
    }
    
    // 特定错误类型的处理
    if (error.message.includes('CSRF token')) {
        Utils.checkAuthentication();
    }
};
```

## 预期效果

通过以上优化，预计可以：
1. **减少代码量**：约 10-15%
2. **提高可维护性**：函数职责更清晰
3. **减少重复**：通用逻辑只需维护一处
4. **更好的错误处理**：统一的错误处理策略
5. **性能提升**：减少重复的 API 调用和状态查询

## 实施建议

1. 逐步实施，每次只改一个模块
2. 每个改动后进行充分测试
3. 保持向后兼容性
4. 使用版本控制跟踪变更
